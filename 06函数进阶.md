# Dart 函数 — 进阶篇（详细且实用）

太好了 — 你要的这部分非常关键，尤其在构建大型 Flutter 应用或写高质量 Dart 库时。下面把**函数体系的进阶内容**做成一份便于查阅的手册：
包括函数类型与 `typedef`、匿名函数与 tear-off、闭包（捕获变量）深入、泛型函数、高阶函数、柯里化、生成器（sync*/async*）、异步函数、尾调用与递归、可空安全与参数向后兼容、以及常见陷阱与最佳实践。每个点都配代码示例与注意事项。

---

# 目录

1. 函数类型（Function Type）
2. `typedef`（类型别名）
3. 匿名函数与箭头函数（Tear-off 与简写）
4. 闭包（Closures）深度解析
5. 泛型函数（Generic Functions）
6. 高阶函数（Higher-order Functions）与常用模式
7. 柯里化（Currying）与部分应用（Partial Application）
8. 生成器：`sync*` / `async*`（可迭代流/Stream）
9. 异步函数与 `Future`/`async`/`await` 进阶
10. 函数作为对象：`call()`、绑定方法与 tear-off 差异
11. 可空安全、参数兼容与向后兼容性策略
12. 性能、调试与常见陷阱
13. 小结：最佳实践清单

---

# 1. 函数类型（Function Type）

Dart 中函数本质是对象（`Function`），函数类型可以被声明并赋值/传递。

```dart
int add(int a, int b) => a + b;

// 显式函数类型
int Function(int, int) op = add;
print(op(2,3)); // 5

// 泛型函数类型
T Function<T>(T) identity = <T>(T x) => x;
print(identity<int>(123)); // 123
```

**要点**

* `int Function(int, int)` 是精确的签名类型，能给 IDE 类型检查。
* `Function` 是通用类型，使用时丢失参数与返回值信息（不推荐做参数类型，除非必要）。

---

# 2. `typedef`（类型别名）

`typedef` 用于给函数类型起名字，便于可读性与复用（支持泛型）。

```dart
typedef Combiner = int Function(int a, int b);

int sum(int a, int b) => a + b;
Combiner c = sum;
print(c(1,2)); // 3

// 泛型 typedef
typedef Factory<T> = T Function();
Factory<String> f = () => 'hello';
print(f()); // hello
```

**要点**

* 用 `typedef` 可以在 API 中暴露语义化类型（例如 `OnPressedCallback`）。
* 自 Dart 2.13 起 `typedef` 支持泛型和函数类型别名语法。

---

# 3. 匿名函数与箭头函数（Tear-off 与简写）

### 匿名函数

```dart
var list = [1,2,3];
list.forEach((x) {
  print(x * 2);
});
```

### 箭头函数（单表达式）

```dart
int square(int n) => n * n;
```

### Tear-off（函数的引用/传递）

```dart
int inc(int x) => x + 1;
var f = inc;         // tear-off：引用函数对象
print([1,2,3].map(f).toList()); // [2,3,4]

// 也可以引用实例方法或静态方法
class A {
  int twice(int x) => x * 2;
}
var a = A();
var t = a.twice; // tear-off，绑定到实例 a 的方法
print(t(3)); // 6
```

**注意**

* `a.twice` 是**绑定方法**（bound tear-off），`A.twice`（静态或未绑定）行为不同。
* 箭头函数仅适用于单表达式并会隐式返回该表达式结果。

---

# 4. 闭包（Closures）深入解析

闭包 = 函数 + 它捕获的外部变量环境（lexical environment）。闭包允许函数在外部作用域变量改变后继续访问或修改它们。

```dart
Function makeCounter() {
  int count = 0;
  return () {
    count += 1;
    return count;
  };
}

void main() {
  var c1 = makeCounter();
  var c2 = makeCounter();
  print(c1()); // 1
  print(c1()); // 2
  print(c2()); // 1  （独立状态）
}
```

**捕获规则与性能**

* 被闭包捕获的变量不会被垃圾回收，直到闭包不再被引用。
* 捕获局部变量会把变量提升到堆上（不像简单局部变量在栈上），因为需要跨越函数生命周期。大量闭包持有大量状态可能影响内存。

**陷阱示例：循环中捕获变量**

```dart
List<Function> makers() {
  var res = <Function>[];
  for (int i = 0; i < 3; i++) {
    res.add(() => print(i));
  }
  return res;
}
void main() {
  var f = makers();
  f.forEach((fn) => fn()); // 输出 3,3,3 （因为 i 最后为 3）
}
```

**修正**：将循环变量复制到局部变量里让每个闭包捕获独立的副本：

```dart
for (int i = 0; i < 3; i++) {
  var j = i;
  res.add(() => print(j));
}
```

---

# 5. 泛型函数（Generic Functions）

函数也可以声明泛型参数，适用于实现类型安全的通用逻辑。

```dart
T identity<T>(T value) => value;

void main() {
  print(identity<int>(123));      // 123
  print(identity<String>('hi'));  // hi
}

// typedef + 泛型
typedef Mapper<T, R> = R Function(T);
R apply<T, R>(T value, Mapper<T, R> mapper) => mapper(value);
```

**要点**

* 泛型函数可与 `typedef` 联合使用以增强可读性。
* 泛型参数能约束返回类型与参数类型关系，提高静态检查。

---

# 6. 高阶函数（Higher-order Functions）与常用模式

高阶函数是能接受函数或返回函数的函数。

### map/filter/reduce

```dart
var nums = [1,2,3,4];
var squares = nums.map((n) => n*n).toList(); // map 返回 Iterable
var evens = nums.where((n) => n % 2 == 0).toList();
var sum = nums.reduce((a,b) => a + b);
```

### 自定义高阶函数

```dart
List<R> transform<T,R>(List<T> list, R Function(T) fn) {
  return list.map(fn).toList();
}
```

### 组合函数（compose）

```dart
T Function(T) compose<T>(T Function(T) f, T Function(T) g) {
  return (T x) => f(g(x));
}
```

---

# 7. 柯里化（Currying）与部分应用（Partial Application）

柯里化：把多参数函数转换成一系列一参函数。

```dart
Function curryAdd(int a) {
  return (int b) => a + b;
}

void main() {
  var add5 = curryAdd(5);
  print(add5(3)); // 8
}
```

部分应用（固定部分参数）：

```dart
int sum3(int a, int b, int c) => a + b + c;
Function(int,int) partialSum(int a) => (b, c) => sum3(a, b, c);

void main() {
  var f = partialSum(10);
  print(f(1,2)); // 13
}
```

---

# 8. 生成器：`sync*` / `async*`（可迭代与 Stream）

生成器可以按需产生值，节省内存并可实现惰性序列。

### 同步生成器（Iterable）

```dart
Iterable<int> countTo(int n) sync* {
  for (int i = 1; i <= n; i++) {
    yield i;
  }
}

void main() {
  for (var x in countTo(3)) print(x); // 1 2 3
}
```

### 异步生成器（Stream）

```dart
Stream<int> asyncCount(int n) async* {
  for (int i = 1; i <= n; i++) {
    await Future.delayed(Duration(milliseconds: 100));
    yield i;
  }
}

void main() async {
  await for (var v in asyncCount(3)) {
    print(v); // 1 2 3 (间隔)
  }
}
```

**要点**

* `yield*` 可以委托另一个 generator。
* `async*` 返回 `Stream<T>`，可以用 `await for` 遍历。

---

# 9. 异步函数与 `Future` / `async` / `await` 进阶

Dart 的异步模型以 `Future` 为核心。

### 基本

```dart
Future<String> fetch() async {
  await Future.delayed(Duration(seconds:1));
  return 'data';
}

void main() async {
  var d = await fetch();
  print(d);
}
```

### 并发执行（并行启动多个 future）

```dart
Future<int> f1() async { await Future.delayed(Duration(seconds:1)); return 1; }
Future<int> f2() async { await Future.delayed(Duration(seconds:2)); return 2; }

void main() async {
  // 启动两个 future（并发），再等待全部完成
  var futures = [f1(), f2()];
  var results = await Future.wait(futures); // [1,2]
  print(results);
}
```

### 错误处理

```dart
try {
  var res = await someAsync();
} catch (e) {
  // 处理异常
}
```

### 超时与取消

* `Future.timeout(Duration, onTimeout: ...)` 可设置超时。
* Dart 没有内建取消 Future 的通用机制（使用 `Isolate`、Stream、或自定义可取消方案）。

---

# 10. 函数作为对象：`call()`、绑定方法与 tear-off 差异

函数是对象：你可以定义类实现 `call()`，使实例可被当函数调用。

```dart
class Adder {
  final int addBy;
  Adder(this.addBy);
  int call(int x) => x + addBy;
}

void main() {
  var add2 = Adder(2);
  print(add2(3)); // 5  （实例可像函数一样调用）
}
```

**绑定方法差异（bound vs unbound）**

* `a.twice` 返回绑定到实例 `a` 的方法（自动把 `this` 传入）。
* `A.twice`（静态）或 `A().twice` 的 tear-off 行为不同，注意在序列化/存储时 `bound` 会持有实例引用。

---

# 11. 可空安全、参数兼容与向后兼容性

Dart 的 null-safety 会影响函数签名兼容：

```dart
int? maybe() => null;           // 返回可空 int
int nonnull() => 1;

int Function()? f1 = maybe;     // OK: maybe 返回 int? 但函数类型是 int Function()? —— 注意不等价，通常要匹配签名精确性
```

更安全的签名匹配规则：

* 当你为参数指定非空类型时，调用方必须提供非空值（或使用 `required`）。
* 使用 `required` 强制命名参数必须传入：

```dart
void fn({required String name}) {}
```

**向后兼容策略**

* 当改变函数签名（添加可选/命名参数、改为可空类型）时，尽量保证旧代码仍能编译通过。
* 如果要破坏性修改，优先新增一个带新名的函数并弃用旧函数（通过注释/文档标注）。

---

# 12. 性能、调试与常见陷阱

### 性能

* 频繁创建闭包会导致分配更多对象；在高性能路径（如渲染循环）避免在每帧创建闭包。
* generator（sync*/async*）易用，但在需要极高吞吐时注意 Stream 的开销。

### 调试建议

* 给匿名函数起个名字或使用 `debugPrint` 帮助追踪。
* 使用 IDE 的“跳入/跳出”跟踪调试闭包捕获问题。

### 常见陷阱回顾

* 循环中捕获循环变量问题（见第 4 节）。
* 动态调用导致运行时错误（使用 `dynamic` 要谨慎）。
* 忘记 `await` 导致逻辑并发问题（`Future` 未被等待）。
* 误用箭头函数：箭头只能包含单表达式，复杂逻辑应用 `{}`。

---

# 13. 小结：最佳实践清单

1. 使用精确的函数类型而非通用 `Function`，提高可读性与类型安全。
2. 使用 `typedef` 给回调命名（例如 `typedef OnSubmit = void Function(String value);`）。
3. 对于公共 API，尽量使用命名参数并标注 `required` 增强可读性。
4. 在高频调用路径避免频繁创建闭包/匿名函数，复用函数引用（tear-off）。
5. 使用 `async`/`await` 编写异步逻辑并捕获异常（`try/catch`）。
6. 对生成器和 Stream 的使用要理解其延迟/惰性特性，避免滥用导致资源被长时间占用。
7. 对可能为 `null` 的参数或返回值明确标注类型（`T?`），并在使用前做检查。
8. 用 `call()` 模式实现可调用对象时注意保持语义清晰（例如实现 `Function` 行为的小工具类）。
9. 写库时保持向后兼容，优先添加新 API 而不是修改原有签名。
10. 在循环或大量数据处理处使用 `for` 比 `forEach` 更容易优化（在极端性能场景下）。

---

# 附：常用示例合集（可直接复制运行）

```dart
// run in dartpad.dev or dart file
int add(int a, int b) => a + b;

typedef Combiner<T> = T Function(T a, T b);

T identity<T>(T x) => x;

Function makeAdder(int n) {
  return (int x) => x + n;
}

Iterable<int> fib(int n) sync* {
  int a = 0, b = 1;
  for (int i = 0; i < n; i++) {
    yield a;
    final t = a + b;
    a = b;
    b = t;
  }
}

Stream<int> asyncCount(int n) async* {
  for (int i = 1; i <= n; i++) {
    await Future.delayed(Duration(milliseconds: 100));
    yield i;
  }
}

void main() async {
  // tear-off demo
  print([1,2,3].map(add).toList()); // [3,5,7] -> map expects int Function(int), add is int Function(int,int) so this is just illustration

  // closure demo
  var add2 = makeAdder(2);
  print(add2(10)); // 12

  // generic
  print(identity<String>('dart')); // dart

  // sync* demo
  print(fib(6).toList()); // [0,1,1,2,3,5]

  // async* demo
  await for (var v in asyncCount(3)) {
    print('stream: $v');
  }
}
```

---

如果你愿意，我可以：

* 把这份内容做成 **Markdown+示例文件**（方便收藏），
* 或者为你把**常见面试题**（闭包、异步并发、生成器相关）配答案与讲解。

你想先要哪个？
