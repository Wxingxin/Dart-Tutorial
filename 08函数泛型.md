非常好 👍，你问的 **Dart 函数泛型（Generic Functions）** 是 Dart 泛型体系中非常实用的部分，尤其在封装工具方法、网络请求封装、数据类型转换等场景中。
下面我将系统地、详细地讲解 Dart 函数泛型的全部核心知识，并结合**经典案例 + 实战示例 + 讲解注释**，让你彻底掌握。

---

## 🌱 一、什么是函数泛型（Generic Functions）

> 泛型函数：允许函数在定义时不指定具体类型，而在**调用时**再确定类型的一种机制。

👉 它让函数可以**“类型参数化”**，从而在保持类型安全的前提下写出更灵活的代码。

---

## 🌰 二、最简单的泛型函数示例

### 🔹 没有泛型的版本

```dart
T echo(T value) {
  return value;
}
```

### 🔹 泛型的版本

```dart
T echo<T>(T value) {
  return value;
}

void main() {
  print(echo<int>(123));     // 输出 123
  print(echo<String>('Hi')); // 输出 Hi
}
```

✅ **解释：**

* `<T>` 是类型参数。
* `T` 可以是任意类型。
* 在调用 `echo` 时，你可以显式地传类型（`echo<int>`），也可以让 Dart 自动推断。

---

## 🎯 三、多个泛型参数的函数

有时一个函数会处理两个不同类型的数据，例如 Map 转换。

```dart
Map<K, V> createMap<K, V>(K key, V value) {
  return {key: value};
}

void main() {
  print(createMap<String, int>('age', 20)); // {age: 20}
  print(createMap<int, String>(1, 'Tom')); // {1: Tom}
}
```

✅ **解释：**

* `<K, V>` 表示有两个泛型参数。
* 这种写法常出现在集合操作或网络层数据转换。

---

## 🧱 四、泛型函数 + 集合操作

Dart 的 `List<T>`、`Map<K, V>` 本身就是泛型类型。
我们可以在函数中接收泛型集合并做操作。

### 示例 1：打印任何类型的 List 元素

```dart
void printList<T>(List<T> items) {
  for (var item in items) {
    print(item);
  }
}

void main() {
  printList<int>([1, 2, 3]);
  printList<String>(['a', 'b', 'c']);
}
```

### 示例 2：过滤列表（类型安全）

```dart
List<T> filterList<T>(List<T> items, bool Function(T) test) {
  List<T> result = [];
  for (var item in items) {
    if (test(item)) result.add(item);
  }
  return result;
}

void main() {
  var numbers = [1, 2, 3, 4, 5];
  var even = filterList(numbers, (n) => n.isEven);
  print(even); // [2, 4]
}
```

✅ **解释：**

* 泛型函数 `filterList` 接收 `List<T>`，返回同类型 `List<T>`。
* `bool Function(T)` 是一个回调函数，接收类型为 `T` 的元素。

---

## 🧩 五、泛型函数 + Class 结合（高级用法）

假设我们有一个通用的网络解析函数：

```dart
T parseResponse<T>(String jsonStr, T Function(Map<String, dynamic>) fromJson) {
  var json = {'name': 'Tom', 'age': 20}; // 模拟 JSON 数据
  return fromJson(json);
}

class User {
  String name;
  int age;
  User(this.name, this.age);

  factory User.fromJson(Map<String, dynamic> json) {
    return User(json['name'], json['age']);
  }

  @override
  String toString() => 'User(name: $name, age: $age)';
}

void main() {
  var user = parseResponse<User>('{}', (data) => User.fromJson(data));
  print(user); // User(name: Tom, age: 20)
}
```

✅ **讲解：**

* 泛型 `T` 用于指定函数返回的数据模型类型。
* 函数内部完全不知道 `T` 是什么类型，由调用方决定。
* 这在 **网络层 JSON → 模型对象** 转换中非常常见。

---

## ⚙️ 六、泛型函数 + 类型约束（extends）

有时我们希望泛型类型必须继承自某个类或实现某个接口。
可以使用 `extends` 关键字来限制类型范围。

### 例子：

```dart
class Animal {
  void speak() => print("Animal speaks");
}

class Dog extends Animal {
  @override
  void speak() => print("Dog barks");
}

void makeSpeak<T extends Animal>(T animal) {
  animal.speak();
}

void main() {
  makeSpeak(Dog());     // Dog barks
  makeSpeak(Animal());  // Animal speaks
  // makeSpeak(123); // ❌ 错误，int 不是 Animal 子类
}
```

✅ **解释：**

* `<T extends Animal>` 限定了类型 T 必须是 `Animal` 或其子类。
* 函数内部可直接调用 `Animal` 的方法。

---

## 🧠 七、泛型 + Future 异步函数（常见于网络封装）

### 示例：通用请求函数

```dart
Future<T> fetchData<T>(Future<Map<String, dynamic>> Function() apiCall, T Function(Map<String, dynamic>) fromJson) async {
  final data = await apiCall(); // 模拟异步请求
  return fromJson(data);
}

class Product {
  final String name;
  final double price;

  Product(this.name, this.price);

  factory Product.fromJson(Map<String, dynamic> json) {
    return Product(json['name'], json['price']);
  }

  @override
  String toString() => 'Product(name: $name, price: $price)';
}

void main() async {
  final api = () async => {'name': 'Laptop', 'price': 9999.99};

  var product = await fetchData<Product>(api, (data) => Product.fromJson(data));
  print(product); // Product(name: Laptop, price: 9999.99)
}
```

✅ **常见于：**

* Flutter 网络封装中（Dio、http）
* 数据层统一解析函数
* JSON → Model 转换

---

## 🧮 八、泛型函数 + 工具方法封装（实战案例）

假设你写一个通用的列表转换工具：

```dart
List<R> mapList<T, R>(List<T> items, R Function(T) convert) {
  return items.map(convert).toList();
}

void main() {
  var numbers = [1, 2, 3];
  var strings = mapList(numbers, (n) => 'No.$n');
  print(strings); // ['No.1', 'No.2', 'No.3']
}
```

✅ **用途：**

* 将任何类型的列表转换为另一种类型。
* 类似 JavaScript 中的 `map()`，但 Dart 泛型让它类型安全。

---

## 💎 九、完整总结（函数泛型思维导图）

| 功能          | 示例                   | 说明        |
| ----------- | -------------------- | --------- |
| 单泛型参数       | `T echo<T>(T value)` | 最基础写法     |
| 多泛型参数       | `<K, V>`             | 常用于 Map   |
| 泛型集合操作      | `<T>`                | 如过滤、排序    |
| 泛型 + 回调     | `Function(T)`        | 高阶函数      |
| 泛型约束        | `<T extends Base>`   | 限制类型范围    |
| 泛型 + Future | `Future<T>`          | 异步网络封装    |
| 泛型 + Class  | `<T>(fromJson)`      | JSON转模型   |
| 泛型 + 工具函数   | `<T, R>`             | 类型安全的转换工具 |

---

## 🧠 十、练习建议（强化学习）

建议你尝试自己动手写以下小练习：

1. ✅ 写一个 `swap<T>(List<T> list, int i, int j)` 交换列表元素的泛型函数。
2. ✅ 写一个 `firstWhereOrNull<T>(List<T> list, bool Function(T) test)`，返回满足条件的第一个元素。
3. ✅ 写一个 `convertList<T, R>(List<T> source, R Function(T) converter)`，实现类型安全转换。

---

是否希望我接下来帮你写一个
👉 **带完整注释、控制台可运行的 Dart 泛型工具函数实战文件**
（比如封装 `filterList`、`mapList`、`parseResponse` 等函数在一个文件中）？
我可以帮你写成一个“Dart 泛型函数工具库”实战模板。
