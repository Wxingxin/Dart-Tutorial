## 🧱 一、对象的创建与基本使用

### 📘 案例1：最基础的对象创建

```dart
class Person {
  String name;
  int age;

  Person(this.name, this.age);

  void sayHello() {
    print('你好，我是$name，今年$age岁。');
  }
}

void main() {
  Person p1 = Person('张三', 20);
  p1.sayHello();
}
```

**输出：**

```
你好，我是张三，今年20岁。
```

🔹 **要点：**

* Dart 用 `class` 定义类。
* 构造函数可以用简写形式 `this.name`、`this.age`。
* 使用 `对象.方法()` 访问方法。

---

## 🧩 二、命名构造函数（Named Constructor）

### 📘 案例2：多种初始化方式

```dart
class Point {
  double x;
  double y;

  Point(this.x, this.y);
  Point.origin() : x = 0, y = 0; // 命名构造函数

  void show() {
    print('点坐标: ($x, $y)');
  }
}

void main() {
  var p1 = Point(3, 4);
  var p2 = Point.origin();

  p1.show();
  p2.show();
}
```

**输出：**

```
点坐标: (3.0, 4.0)
点坐标: (0.0, 0.0)
```

🔹 **要点：**

* 命名构造函数让同一个类有不同创建方式。
* 类似 Java 的“构造方法重载”。

---

## ⚙️ 三、工厂构造函数（factory）

### 📘 案例3：单例模式（经典）

```dart
class Database {
  static final Database _instance = Database._internal();

  factory Database() {
    return _instance;
  }

  Database._internal() {
    print('数据库已初始化');
  }

  void query() {
    print('查询数据中...');
  }
}

void main() {
  var db1 = Database();
  var db2 = Database();

  print(identical(db1, db2)); // true
  db1.query();
}
```

**输出：**

```
数据库已初始化
true
查询数据中...
```

🔹 **要点：**

* `factory` 构造函数不会每次都创建新对象。
* 这是 Dart 中实现 **单例模式** 的经典写法。

---

## 👨‍👩‍👧 四、继承与重写（extends / override）

### 📘 案例4：继承 Animal 类

```dart
class Animal {
  void eat() {
    print('动物正在吃东西');
  }
}

class Dog extends Animal {
  @override
  void eat() {
    print('狗在啃骨头');
  }

  void bark() {
    print('汪汪汪！');
  }
}

void main() {
  Dog dog = Dog();
  dog.eat();
  dog.bark();
}
```

**输出：**

```
狗在啃骨头
汪汪汪！
```

🔹 **要点：**

* 使用 `extends` 继承父类。
* 使用 `@override` 重写方法。

---

## 🧬 五、抽象类（abstract）

### 📘 案例5：统一接口标准

```dart
abstract class Shape {
  void draw(); // 抽象方法
}

class Circle extends Shape {
  @override
  void draw() {
    print('画一个圆形');
  }
}

class Square extends Shape {
  @override
  void draw() {
    print('画一个正方形');
  }
}

void main() {
  List<Shape> shapes = [Circle(), Square()];
  for (var s in shapes) {
    s.draw();
  }
}
```

**输出：**

```
画一个圆形
画一个正方形
```

🔹 **要点：**

* 抽象类不能直接实例化。
* 常用于定义接口或通用规范。

---

## 🧰 六、接口与多实现（implements）

### 📘 案例6：多个接口实现

```dart
class Flyable {
  void fly() {}
}

class Swimmable {
  void swim() {}
}

class Duck implements Flyable, Swimmable {
  @override
  void fly() => print('鸭子飞得不高');
  @override
  void swim() => print('鸭子在水里游');
}

void main() {
  Duck duck = Duck();
  duck.fly();
  duck.swim();
}
```

**输出：**

```
鸭子飞得不高
鸭子在水里游
```

🔹 **要点：**

* Dart 没有多继承，但支持多接口实现。
* `implements` 要求完全实现接口中所有方法。

---

## 🧩 七、继承与 super 调用父类

### 📘 案例7：调用父类构造函数

```dart
class Person {
  String name;
  Person(this.name);
}

class Student extends Person {
  int grade;
  Student(String name, this.grade) : super(name);

  void showInfo() {
    print('$name 是 $grade 年级学生');
  }
}

void main() {
  var s = Student('李四', 2);
  s.showInfo();
}
```

**输出：**

```
李四 是 2 年级学生
```

🔹 **要点：**

* 使用 `super(...)` 调用父类构造函数。

---

## 🧠 八、静态成员（static）

### 📘 案例8：类级变量与方法

```dart
class MathUtil {
  static const double PI = 3.14159;

  static double circleArea(double r) {
    return PI * r * r;
  }
}

void main() {
  print(MathUtil.circleArea(5));
}
```

**输出：**

```
78.53975
```

🔹 **要点：**

* 静态成员属于类，而非对象。
* 可直接通过类名访问。

---

## 🧳 九、Getter / Setter

### 📘 案例9：私有属性的封装

```dart
class Account {
  double _balance = 0;

  double get balance => _balance;

  set balance(double value) {
    if (value >= 0) {
      _balance = value;
    } else {
      print('余额不能为负数');
    }
  }
}

void main() {
  var a = Account();
  a.balance = 100;
  print('当前余额：${a.balance}');
  a.balance = -20;
}
```

**输出：**

```
当前余额：100.0
余额不能为负数
```

🔹 **要点：**

* 使用 `_` 开头表示私有变量（仅文件内可见）。
* 通过 getter/setter 控制访问逻辑。

---

## 🧾 十、对象拷贝（复制对象）

### 📘 案例10：实现拷贝构造

```dart
class User {
  String name;
  int age;

  User(this.name, this.age);

  User.clone(User other)
      : name = other.name,
        age = other.age;
}

void main() {
  var u1 = User('小明', 20);
  var u2 = User.clone(u1);
  print('${u1.name}, ${u1.age}');
  print('${u2.name}, ${u2.age}');
}
```

**输出：**

```
小明, 20
小明, 20
```

🔹 **要点：**

* 自定义拷贝构造函数可实现深拷贝效果。

---

## 🧱 十一、对象比较（== 与 hashCode）

### 📘 案例11：自定义对象相等规则

```dart
class Point {
  int x, y;

  Point(this.x, this.y);

  @override
  bool operator ==(Object other) =>
      other is Point && x == other.x && y == other.y;

  @override
  int get hashCode => x.hashCode ^ y.hashCode;
}

void main() {
  var p1 = Point(1, 2);
  var p2 = Point(1, 2);

  print(p1 == p2); // true
}
```

🔹 **要点：**

* 重写 `==` 和 `hashCode` 可让对象比较逻辑自定义。

---

## 🧩 十二、对象转 JSON（toJson）

### 📘 案例12：与接口数据交互（前后端常用）

```dart
import 'dart:convert';

class User {
  String name;
  int age;

  User(this.name, this.age);

  Map<String, dynamic> toJson() => {'name': name, 'age': age};

  User.fromJson(Map<String, dynamic> json)
      : name = json['name'],
        age = json['age'];
}

void main() {
  var u = User('Tom', 25);
  String jsonStr = jsonEncode(u.toJson());
  print(jsonStr);

  var newUser = User.fromJson(jsonDecode(jsonStr));
  print('${newUser.name}, ${newUser.age}');
}
```

**输出：**

```
{"name":"Tom","age":25}
Tom, 25
```

🔹 **要点：**

* 在网络请求中，Dart 对象常用 `toJson()` 与 `fromJson()` 转换。

---

如果你想更进一步，我可以接着写第 13～20 部分（包括：**对象集合操作、Mixin 混入、对象比较排序、拷贝与深拷贝、反射、泛型类、对象生命周期** 等高级应用）。
是否继续？
