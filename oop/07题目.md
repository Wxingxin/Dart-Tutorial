好的，为您准备了一系列 Dart 面向对象编程 (OOP) 的练习题，涵盖了从基础到高级的知识点，并提供详细的答案解析。

-----

## Dart 面向对象编程 (OOP) 练习题及解析

### 练习题一：基础类与构造函数

**【题目】**

设计一个名为 `Book` 的类，它具有以下属性和功能：

1.  **属性**：`title` (书名, String), `author` (作者, String), `year` (出版年份, int)。
2.  **构造函数**：使用**命名参数**来初始化所有属性。
3.  **方法**：`getBookInfo()`，打印出所有书籍信息。

**【代码实现】**

```dart
// 你的代码写在这里
class Book {
  String title;
  String author;
  int year;

  // 1. 命名参数构造函数
  Book({required this.title, required this.author, required this.year});

  // 2. getBookInfo 方法
  void getBookInfo() {
    print('书名: $title');
    print('作者: $author');
    print('年份: $year');
  }
}

void main() {
  // 测试代码
  var book1 = Book(
    title: '老人与海',
    author: '海明威',
    year: 1952,
  );
  book1.getBookInfo();
}
```

**【答案解析】**

1.  **类定义**：使用 `class Book { ... }` 标准定义。
2.  **构造函数**：使用**语法糖** `this.title` 等简化赋值。关键在于 `{...}` 结构来定义**命名可选参数**，并使用 `required` 关键字确保调用者必须提供这些值。
3.  **实例化**：调用时必须显式指定参数名，如 `title: '...'`，提高了代码可读性。

-----

### 练习题二：封装与 Getter/Setter

**【题目】**

设计一个名为 `BankAccount` 的银行账户类：

1.  **属性**：`_balance` (余额, double)。该属性必须是**私有**的，只能在类内部修改。
2.  **方法**：
      * `deposit(double amount)`：存款，增加余额。
      * `withdraw(double amount)`：取款，如果余额足够则减少余额，否则打印“余额不足”。
3.  **访问器**：
      * 提供一个 `get balance` 访问器，用于**安全地读取**当前余额。
      * **不允许提供 Setter**，以防止外部直接修改余额。

**【代码实现】**

```dart
// 你的代码写在这里
class BankAccount {
  // 1. 私有属性 (库私有)
  double _balance = 0.0; 

  // 2. Getter (读取余额)
  double get balance => _balance;

  // 3. 存款方法
  void deposit(double amount) {
    if (amount > 0) {
      _balance += amount;
      print('成功存入 $amount 元. 当前余额: $_balance');
    } else {
      print('存款金额必须大于零.');
    }
  }

  // 4. 取款方法
  void withdraw(double amount) {
    if (amount <= 0) {
      print('取款金额必须大于零.');
      return;
    }
    
    if (_balance >= amount) {
      _balance -= amount;
      print('成功取出 $amount 元. 当前余额: $_balance');
    } else {
      print('取款失败: 余额不足 ($_balance).');
    }
  }
}

void main() {
  // 测试代码
  var account = BankAccount();
  account.deposit(1000.0);
  account.withdraw(200.0);
  account.withdraw(1000.0); // 预期失败
  
  // 使用 Getter 读取余额
  print('最终余额: ${account.balance}'); 
  
  // 尝试直接访问私有属性 (在 main 函数中无法直接访问 _balance)
  // account._balance = 999.0; // 错误，无法直接访问
}
```

**【答案解析】**

1.  **封装**：使用前缀 `_` 将 `_balance` 标记为**库私有**。在实际项目中，如果在另一个文件（另一个库）中，该属性将无法访问，实现了封装。
2.  **Getter**：`double get balance => _balance;` 提供了一个公共的、只读的接口来获取内部私有数据，但禁止了直接修改。
3.  **方法**：`deposit` 和 `withdraw` 是唯一能改变内部状态的途径，保证了对数据的控制和校验。

-----

### 练习题三：继承与多态

**【题目】**

模拟一个动物系统：

1.  创建一个**父类** `Animal`，包含属性 `name` 和一个方法 `makeSound()`，该方法默认打印 "Animal makes a sound."
2.  创建一个**子类** `Dog`，继承自 `Animal`。
3.  在 `Dog` 类中**重写** (Override) `makeSound()` 方法，使其打印 "Dog barks."

**【代码实现】**

```dart
// 你的代码写在这里
// 1. 父类 Animal
class Animal {
  String name;

  Animal(this.name);

  void makeSound() {
    print('$name: Animal makes a sound.');
  }
}

// 2. 子类 Dog
class Dog extends Animal {
  // 子类构造函数必须调用父类构造函数 (隐式或显式)
  Dog(String name) : super(name); 

  // 3. 重写 makeSound 方法
  @override
  void makeSound() {
    print('$name: Dog barks.');
  }
}

void main() {
  // 测试代码
  Animal genericAnimal = Animal('Tom');
  Dog myDog = Dog('Buddy');
  
  genericAnimal.makeSound(); // 输出父类方法
  myDog.makeSound();         // 输出子类重写的方法 (多态体现)
  
  // 多态的应用：用父类类型引用子类对象
  Animal polyAnimal = Dog('Rex');
  polyAnimal.makeSound(); // 仍然调用 Dog 的方法
}
```

**【答案解析】**

1.  **继承**：使用 `extends Animal` 建立父子关系。
2.  **构造函数链**：`Dog(String name) : super(name);` 确保在初始化 `Dog` 之前，先正确初始化了父类 `Animal` 的 `name` 属性。
3.  **多态**：`@override` 标记表明子类提供了自定义实现。当使用父类类型 `Animal` 来引用子类对象 `Dog` 时，调用的仍是子类**实际**的方法，体现了运行时多态性。

-----

### 练习题四：抽象类与隐式接口

**【题目】**

创建一个规范系统：

1.  创建一个名为 `Shape` 的**抽象类**，包含一个抽象方法 `getArea()` (返回 double)。
2.  创建一个名为 `Measurable` 的**普通类**，其中有一个方法 `calculatePerimeter()` (返回 double)。
3.  创建一个具体类 `Rectangle`：
      * **继承** `Shape` 类，并实现 `getArea()`。
      * **实现** `Measurable` 类作为接口，并实现 `calculatePerimeter()`。

**【代码实现】**

```dart
// 你的代码写在这里
// 1. 抽象类 Shape
abstract class Shape {
  // 抽象方法 (没有方法体)
  double getArea(); 
}

// 2. 普通类 Measurable (作为接口被实现)
class Measurable {
  double calculatePerimeter() {
    // 接口不需要默认实现，但普通类需要。这里只是一个示例。
    throw UnimplementedError(); 
  }
}

// 3. 具体类 Rectangle
class Rectangle extends Shape implements Measurable {
  double width;
  double height;

  Rectangle(this.width, this.height);

  // 继承自 Shape 的抽象方法，必须实现
  @override
  double getArea() {
    return width * height;
  }

  // 实现自 Measurable 接口的方法，必须实现
  @override
  double calculatePerimeter() {
    return 2 * (width + height);
  }
}

void main() {
  // 测试代码
  var rect = Rectangle(10.0, 5.0);

  // 继承的方法
  print('矩形面积: ${rect.getArea()}'); // 50.0

  // 接口实现的方法
  print('矩形周长: ${rect.calculatePerimeter()}'); // 30.0
  
  // 类型的多态检查
  print('是否为 Shape: ${rect is Shape}');         // true
  print('是否为 Measurable: ${rect is Measurable}'); // true
}
```

**【答案解析】**

1.  **抽象**：`abstract class Shape` 规范了所有形状都必须有 `getArea` 能力。
2.  **继承 (`extends`)**：`Rectangle extends Shape` 继承了 `Shape` 的结构，并强制要求实现其抽象方法。
3.  **接口 (`implements`)**：`implements Measurable` 表示 `Rectangle` 承诺实现 `Measurable` 类中的所有公共方法，即使 `Measurable` 是一个普通类。**Dart 中所有类都可以作为接口使用。**

-----

### 练习题五：Mixins

**【题目】**

创建一个 Mixin 系统，用于给不同的类添加飞行能力：

1.  创建一个名为 `Flyable` 的 **Mixin**，包含一个方法 `fly()`，打印 "I am flying\!"
2.  创建一个 `Duck` 类，使用 `with` 关键字混入 `Flyable`。
3.  创建一个 `Car` 类，**不**混入 `Flyable`。

**【代码实现】**

```dart
// 你的代码写在这里
// 1. 定义 Mixin
mixin Flyable {
  void fly() {
    print('I am flying!');
  }
}

// 2. Duck 类混入 Flyable
class Duck with Flyable {
  void quack() => print('Quack!');
}

// 3. Car 类 (不混入)
class Car {
  void drive() => print('Vroom!');
}

void main() {
  // 测试代码
  var duck = Duck();
  var car = Car();

  // Duck 拥有了 fly 方法
  duck.quack(); 
  duck.fly();   

  // Car 只有 drive 方法
  car.drive();  

  // 检查类型：Mixin 是类型检查的一部分
  print('Duck是否可飞: ${duck is Flyable}'); // true
  print('Car是否可飞: ${car is Flyable}');  // false
}
```

**【答案解析】**

1.  **Mixin 定义**：使用 `mixin` 关键字。
2.  **Mixin 混入**：使用 `class Duck with Flyable`。`Duck` 类获得了 `Flyable` 中的所有方法和属性，而不需要继承，实现了灵活的代码复用。
3.  **类型检查**：Mixin 增加了类的能力，同时也改变了它的类型。`duck is Flyable` 返回 `true`。