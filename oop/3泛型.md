太好了 👍 我来给你系统讲解一下 **Dart 中类（class）里泛型（Generics）的使用**，我们会从 **最简单的概念开始**，再配上 **经典+实战案例**，保证你一看就会。

---

## 🧠 一、什么是泛型（Generics）

> 泛型就是：让 **类、方法、接口** 能适配 **多种类型的数据**，而不用重复写相同的逻辑。

比如：

* 你有一个保存数据的类；
* 你可能想保存 `int`、`String`、`double` 类型；
* 泛型就能让你写 **一份代码**，适配 **多种类型**。

---

## 🧩 二、最简单的泛型类

```dart
// 定义一个泛型类
class Box<T> {
  T content; // T 表示类型参数
  Box(this.content);

  void showContent() {
    print("盒子里装的是: $content");
  }
}

void main() {
  var box1 = Box<int>(123); // T = int
  var box2 = Box<String>("Dart"); // T = String
  var box3 = Box<double>(3.14); // T = double

  box1.showContent(); // 输出: 盒子里装的是: 123
  box2.showContent(); // 输出: 盒子里装的是: Dart
  box3.showContent(); // 输出: 盒子里装的是: 3.14
}
```

🧩 **解释：**

* `<T>` 是泛型参数，意思是“我还不知道你要传什么类型”；
* 创建对象时，`Box<int>` 表示这个盒子里只能装 `int`；
* 泛型让类可以 **复用逻辑**，避免重复写代码。

---

## 🎯 三、多个泛型参数

有时候一个类需要两个或多个泛型：

```dart
class Pair<K, V> {
  K key;
  V value;

  Pair(this.key, this.value);

  void showPair() {
    print("键: $key, 值: $value");
  }
}

void main() {
  var p1 = Pair<String, int>("年龄", 20);
  var p2 = Pair<int, String>(1, "张三");

  p1.showPair(); // 键: 年龄, 值: 20
  p2.showPair(); // 键: 1, 值: 张三
}
```

🧠 常见于：

* Map（键值对）
* 数据库记录对象（ID + 数据）

---

## ⚙️ 四、泛型 + 继承（extends 限制类型）

有时你希望泛型只能接受 **某些类型**。

```dart
class Animal {
  void speak() => print("动物叫");
}

class Dog extends Animal {
  @override
  void speak() => print("汪汪汪");
}

class Cat extends Animal {
  @override
  void speak() => print("喵喵喵");
}

// 只允许传入继承自 Animal 的类型
class Zoo<T extends Animal> {
  List<T> animals = [];

  void addAnimal(T animal) {
    animals.add(animal);
  }

  void soundAll() {
    for (var a in animals) {
      a.speak();
    }
  }
}

void main() {
  var zoo = Zoo<Dog>(); // ✅ Dog 继承自 Animal
  zoo.addAnimal(Dog());
  zoo.soundAll(); // 输出: 汪汪汪

  // var zoo2 = Zoo<String>(); ❌ 错误，String 不是 Animal
}
```

🦁 **解释：**

* `<T extends Animal>` 限制 T 必须是 `Animal` 的子类；
* 这样在类里就可以安全地使用 `Animal` 的方法。

---

## 🧰 五、泛型方法（Generic Function）

不仅类能泛型，方法也可以使用泛型：

```dart
T getFirst<T>(List<T> items) {
  return items.first;
}

void main() {
  print(getFirst<int>([1, 2, 3]));       // 输出: 1
  print(getFirst<String>(["A", "B"]));   // 输出: A
}
```

🧠 泛型方法可以独立使用，不一定要定义在类里。

---

## 📦 六、泛型 + 实战：缓存管理类（Cache）

下面是一个 **实际开发中会用到的经典例子** 👇

```dart
class Cache<T> {
  final Map<String, T> _cache = {};

  void setItem(String key, T value) {
    _cache[key] = value;
  }

  T? getItem(String key) {
    return _cache[key];
  }
}

void main() {
  // 保存字符串缓存
  var stringCache = Cache<String>();
  stringCache.setItem("name", "Dart");
  print(stringCache.getItem("name")); // 输出: Dart

  // 保存数字缓存
  var intCache = Cache<int>();
  intCache.setItem("score", 100);
  print(intCache.getItem("score")); // 输出: 100
}
```

💡 **实战启示：**

* 泛型让我们写一个通用缓存类；
* 无论是 `int`、`String` 还是 `自定义对象`，都能安全存取；
* 在 Flutter、服务端 Dart 开发中常用。

---

## 💬 七、泛型 + 自定义对象实战

```dart
class User {
  String name;
  int age;
  User(this.name, this.age);
}

class Repository<T> {
  final List<T> _data = [];

  void add(T item) => _data.add(item);
  void showAll() => _data.forEach((item) => print(item));
}

void main() {
  var userRepo = Repository<User>();
  userRepo.add(User("张三", 20));
  userRepo.add(User("李四", 22));

  userRepo.showAll(); // 输出: Instance of 'User'...
}
```

📘 改进：

```dart
class User {
  String name;
  int age;
  User(this.name, this.age);

  @override
  String toString() => "User(name: $name, age: $age)";
}
```

输出：

```
User(name: 张三, age: 20)
User(name: 李四, age: 22)
```

---

## 🚀 八、总结表格

| 类型   | 定义形式                     | 说明         | 示例                    |
| ---- | ------------------------ | ---------- | --------------------- |
| 泛型类  | `class Box<T>`           | 定义支持多种类型的类 | `Box<int>`            |
| 多泛型  | `class Pair<K,V>`        | 支持两个类型参数   | `Pair<String,int>`    |
| 泛型约束 | `<T extends Animal>`     | 限制类型范围     | `Zoo<Dog>`            |
| 泛型方法 | `T getFirst<T>(List<T>)` | 方法支持多类型    | `getFirst<int>(list)` |

---

是否希望我接着给你讲讲 **Dart 泛型在函数和接口中的高级用法（如泛型接口、泛型工厂、泛型 mixin）**？
这些是 Dart 面试题常考的部分，也能帮你从小白进阶到进阶开发者。
